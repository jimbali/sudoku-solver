"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const house_1 = require("../utils/house");
const candidate_1 = require("../utils/candidate");
const remeda_1 = require("remeda");
var BruteForceMode;
(function (BruteForceMode) {
    BruteForceMode[BruteForceMode["DepthFirstSearch"] = 0] = "DepthFirstSearch";
    // TODO: DancingLinks,
    // TODO: AriadnesThread,
})(BruteForceMode = exports.BruteForceMode || (exports.BruteForceMode = {}));
/**
 * Solves a grid using the depth-first search bactracking algorithm.
 *
 * @private
 * @since 0.0.1
 *
 * @param {SudokuGrid} grid The grid to solve.
 * @returns {ReadonlyMap<GridIndex, Digit> | undefined} The solution of the grid if it has been found; otherwise,
 * `undefined`.
 *
 * @see https://en.wikipedia.org/wiki/Depth-first_search
 */
function solveWithDFS(grid) {
    const digits = [...grid.digits.entries()];
    const candidates = [...(grid.candidates.size > 0 ? grid.candidates.entries() : candidate_1.getCandidates(grid.digits).entries())];
    function areValidHouses(solution, houses) {
        // Creates a grid with solution that is currently evaluated
        const tempGrid = {
            digits: new Map([...digits, ...solution]),
            candidates: new Map(),
        };
        // Returns false if at least one house is invalid; otherwise, returns undefined
        const isInvalidOrUndefined = remeda_1.pipe(houses, remeda_1.map((house) => house_1.isValidHouse({ grid: tempGrid, house })), remeda_1.filter((isValid) => !isValid), remeda_1.first());
        return isInvalidOrUndefined === false ? false : true;
    }
    // Verify that the clues and the guesses make a complete grid
    const isComplete = (solution) => digits.length + solution.length === 81;
    // Recursive function that will guess digits in every empty cell until it finds the solution
    function depthFirstSearch(index, previousSolution = []) {
        if (isComplete(previousSolution)) {
            // Return the complete solution to the caller, terminating the recursive function
            return previousSolution;
        }
        else {
            const indexInGrid = candidates[index][0];
            const houses = house_1.getCellHouses(indexInGrid);
            // Try candidates in the current cell and recursively call depthFirstSearch on the next cell
            // to find if it is valid
            const results = remeda_1.pipe(candidates[index][1], remeda_1.map((digit) => [...previousSolution, [indexInGrid, digit]]), remeda_1.filter((solution) => areValidHouses(solution, houses)), remeda_1.map((solution) => depthFirstSearch((index + 1), solution)), remeda_1.filter((solution) => solution !== undefined), remeda_1.first());
            // Returns the complete solution if it has been found
            // or undefined if no valid solution has been found for this alternative
            return results;
        }
    }
    // Start the bruteforce, return the solution if it has been found or undefined
    const solution = depthFirstSearch(0);
    return solution ? new Map([...digits, ...solution]) : undefined;
}
// TODO
// /**
//  * Solves a grid using the dancing links bactracking algorithm.
//  *
//  * @private
//  * @todo
//  *
//  * @param {SudokuGrid} grid The grid to solve.
//  * @returns {ReadonlyMap<GridIndex, Digit> | undefined} The solution of the grid if it has been found; otherwise,
//  * `undefined`.
//  *
//  * @see http://sudopedia.enjoysudoku.com/Dancing_Links.html
//  * @see https://en.wikipedia.org/wiki/Dancing_Links
//  */
// function solveWithDancingLinks(grid: SudokuGrid): ReadonlyMap<GridIndex, Digit> | undefined {
//   return grid ? undefined : undefined;
// }
// TODO
// /**
//  * Solves a grid using the Ariadne's thread bactracking algorithm.
//  *
//  * @private
//  * @todo
//  *
//  * @param {SudokuGrid} grid The grid to solve.
//  * @returns {ReadonlyMap<GridIndex, Digit> | undefined} The solution of the grid if it has been found; otherwise,
//  * `undefined`.
//  *
//  * @see http://sudopedia.enjoysudoku.com/Ariadne%27s_Thread.html
//  * @see https://en.wikipedia.org/wiki/Ariadne%27s_thread_%28logic%29
//  */
// function solveWithAriadnesThread(grid: SudokuGrid): ReadonlyMap<GridIndex, Digit> | undefined {
//   return grid ? undefined : undefined;
// }
/**
 * Solves a grid using a backtracking algorithm.
 *
 * The program will place a digit into a cell (following the constraints of the game), and continue until it finds the
 * solution or hits a dead end. If the algorithm cannot place any new digit according to the constraints of the game,
 * meaning it has reached a dead end, it removes the one or several placed digits and tries a new alternative. This
 * process continue until either all alternatives have been tried or the grid has been solved.
 *
 * **Note:** This process can be slow. Some grids are also designed to resist this kind of algorithm for a longer time.
 *
 * @summary Solves a grid using a backtracking algorithm.
 *
 * @since 0.0.1
 *
 * @param {SudokuGrid} grid The grid to solve.
 * @param {BruteForceMode} mode The type of algorithm to use to solve the puzzle.
 * @returns {ReadonlyMap<GridIndex, Digit> | undefined} The solution of the grid if it has been found; otherwise,
 * `undefined`.
 *
 * @example
 * const grid = parseGrid(`
 *   +---+---+---+
 *   |-7-|2-3|-8-|
 *   |345|798|126|
 *   |2-8|-4-|---|
 *   +---+---+---+
 *   |4--|5-9|8-2|
 *   |-5-|8-4|-9-|
 *   |8--|---|--1|
 *   +---+---+---+
 *   |---|---|--8|
 *   |-8-|---|-7-|
 *   |62-|-87|-15|
 *   +---+---+---+`);
 * const solution = solveWithBacktracking(grid);
 * serializeGrid({ digits: solution, candidates: new Map() });
 * // => "971263584345798126268145937437519862156824793892376451713952648584631279629487315"
 *
 * @see http://sudopedia.enjoysudoku.com/Backtracking_Algorithms.html
 * @see https://en.wikipedia.org/wiki/Backtracking
 * @see https://en.wikipedia.org/wiki/Sudoku_solving_algorithms
 */
function solveWithBacktracking(grid, mode = BruteForceMode.DepthFirstSearch) {
    switch (mode) {
        case BruteForceMode.DepthFirstSearch:
            return solveWithDFS(grid);
        // TODO:
        // case BruteForceMode.DancingLinks:
        //   return solveWithDancingLinks(grid);
        // TODO:
        // case BruteForceMode.AriadnesThread:
        //   return solveWithAriadnesThread(grid);
        default:
            return;
    }
}
exports.solveWithBacktracking = solveWithBacktracking;
