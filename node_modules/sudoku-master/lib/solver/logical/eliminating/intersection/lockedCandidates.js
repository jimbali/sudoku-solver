"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const remeda_1 = require("remeda");
const house_1 = require("../../../../utils/house");
const candidate_1 = require("../../../../utils/candidate");
const cell_1 = require("../../../../utils/cell");
const findLockedCandidates = (candidates, box, intersections) => {
    return remeda_1.pipe(intersections, remeda_1.flatMap((line) => remeda_1.pipe(candidate_1.findIntersectingCandidates(candidates, box, line, 2), remeda_1.map((digit) => {
        const pointing = candidate_1.getCellsContainingCandidate(digit, candidates, remeda_1.difference(line.cells, box.cells));
        const claiming = candidate_1.getCellsContainingCandidate(digit, candidates, remeda_1.difference(box.cells, line.cells));
        return {
            box,
            line,
            digit,
            pointing: pointing.length > 0 && claiming.length === 0 ? pointing : [],
            claiming: claiming.length > 0 && pointing.length === 0 ? claiming : [],
        };
    }), remeda_1.filter((result) => result.pointing.length > 0 || result.claiming.length > 0))));
};
const getLockedCandidatesEliminationResult = (lockedCandidates) => {
    if (lockedCandidates.pointing.length > 0) {
        return {
            technique: "Locked Candidates Type 1 (Pointing)",
            eliminations: [
                {
                    digit: lockedCandidates.digit,
                    coords: remeda_1.map(lockedCandidates.pointing, cell_1.getCellCoord),
                },
            ],
            implication: {
                type: types_1.EliminationImplicationType.DigitInHouse,
                house: lockedCandidates.box,
                digit: lockedCandidates.digit,
            },
        };
    }
    else {
        return {
            technique: "Locked Candidates Type 2 (Claiming)",
            eliminations: [
                {
                    digit: lockedCandidates.digit,
                    coords: remeda_1.map(lockedCandidates.claiming, cell_1.getCellCoord),
                },
            ],
            implication: {
                type: types_1.EliminationImplicationType.DigitInHouse,
                house: lockedCandidates.line,
                digit: lockedCandidates.digit,
            },
        };
    }
};
/**
 * When all candidates for a digit in a house are located inside the intersection with another house, we can eliminate
 * the remaining candidates from the second house outside the intersection.
 *
 * @since 0.0.3
 *
 * @param grid The grid to solve.
 * @returns A list of objects describing where a candidate can be eliminated.
 *
 * @example
 * const grid = parseGrid("2.....1..14..2..83..3.1.5.............67...5.8.92.13.......32....18.2.3....16..94", true);
 * const results = eliminateLockedCandidates(grid);
 * eliminationDescription(results[0]);
 * // => "Locked Candidates Type 1 (Pointing): 4 in b3 => r46c8<>4"
 *
 * @see http://sudopedia.enjoysudoku.com/Locked_Candidates.html
 */
function eliminateLockedCandidates(grid) {
    return remeda_1.pipe(house_1.HOUSES_LIST, remeda_1.filter((house) => house.type === "box"), remeda_1.map((box) => findLockedCandidates(grid.candidates, box, house_1.findIntersectingHouses(box))), remeda_1.filter((lockedCandidates) => lockedCandidates.length > 0), remeda_1.flatten, remeda_1.map(getLockedCandidatesEliminationResult));
}
exports.eliminateLockedCandidates = eliminateLockedCandidates;
