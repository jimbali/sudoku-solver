"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const remeda_1 = require("remeda");
const types_1 = require("../types");
const house_1 = require("../../../../utils/house");
const subset_1 = require("../../../../utils/subset");
const house_2 = require("../../../../utils/house");
const types_2 = require("./types");
const candidate_1 = require("../../../../utils/candidate");
const cell_1 = require("../../../../utils/cell");
const getNakedSubsetData = (candidates) => {
    return (house) => {
        return {
            house,
            lookup: house_2.getHouseCandidates(house, candidates),
        };
    };
};
const getNakedSubsetEliminationResult = (candidates, level) => {
    return (subset) => {
        var _a;
        const houses = house_1.getCellsCommonHouses(subset.result.subsetValues);
        const subsetType = houses === undefined || houses[1] !== undefined ? "Locked" : "Naked";
        const housesCells = houses !== undefined ? remeda_1.concat(houses[0].cells, ((_a = houses[1]) === null || _a === void 0 ? void 0 : _a.cells) || []) : [];
        const solvableCells = remeda_1.difference(housesCells, subset.result.subsetValues);
        return {
            technique: `${subsetType} ${types_2.SUBSET_LEVEL_LABEL.get(level)}`,
            eliminations: remeda_1.pipe(subset.result.subsetIndexes, remeda_1.map((digit) => {
                return {
                    digit,
                    coords: remeda_1.map(candidate_1.getCellsContainingCandidate(digit, candidates, solvableCells), cell_1.getCellCoord),
                };
            }), remeda_1.filter((elim) => elim.coords.length > 0)),
            implication: {
                type: types_1.EliminationImplicationType.Subset,
                cells: remeda_1.map(subset.result.subsetValues, cell_1.getCellCoord),
                digits: subset.result.subsetIndexes,
            },
        };
    };
};
/**
 * A Naked Subset is formed by N cells in a house with candidates for exactly N digits. It causes the elimination of the
 * digits that are on the same house but not in the cells of the subet.
 *
 * **Note:** When all cells are located in an intersection, spotting the subset is much easier. Because there are only
 * three cells in an intersection, it is not possible to find Naked Quadruples in an intersection. The subset can cause
 * eliminations in both intersecting houses.
 *
 * @since 0.0.3
 *
 * @param grid The grid to solve.
 * @param level The level of the subset to find.
 * @returns A list of objects describing where a candidate can be eliminated.
 *
 * @example
 * const grid = parseGrid(
 *   ":0201:6:...+2+94+3+8....17+86+4.48.3561....4+8+375.+1...+41+57..5..+62+9+83495+3+7+8+2+4+1612+6+5+4+3+9+78.+4.+9+6+1+2+5+3::612: ",
 *   true,
 * );
 * const results = eliminateNakedSubset(grid, SubsetType.Triple);
 * eliminationDescription(results[0]);
 * // => "Naked Triple: 3,6,9 in r245c2 => r1c2<>6"
 *
 * @see http://sudopedia.enjoysudoku.com/Naked_Subset.html
 * @see http://sudopedia.enjoysudoku.com/Naked_Pair.html
 * @see http://sudopedia.enjoysudoku.com/Naked_Triple.html
 * @see http://sudopedia.enjoysudoku.com/Naked_Quad.html
 * @see http://sudopedia.enjoysudoku.com/Locked_Pair.html
 * @see http://sudopedia.enjoysudoku.com/Locked_Triple.html
 */
function eliminateNakedSubset(grid, level) {
    return remeda_1.pipe(house_1.HOUSES_LIST, remeda_1.map(getNakedSubsetData(grid.candidates)), remeda_1.map(subset_1.findSubsets(level)), remeda_1.flatten(), remeda_1.map(getNakedSubsetEliminationResult(grid.candidates, level)), remeda_1.filter((result) => result.eliminations.length > 0));
}
exports.eliminateNakedSubset = eliminateNakedSubset;
