"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../../../types");
const subset_1 = require("../../../../utils/subset");
const types_2 = require("../types");
const remeda_1 = require("remeda");
const candidate_1 = require("../../../../utils/candidate");
const cell_1 = require("../../../../utils/cell");
const ramda_1 = require("ramda");
const subset_2 = require("../subset");
const house_1 = require("../../../../utils/house");
const getLookup = (candidates) => {
    return (digit) => {
        return remeda_1.pipe(types_1.VALID_LINE_TYPES, remeda_1.map((line) => {
            const lineIndex = line === "row" ? 1 : 0;
            return {
                line,
                digit,
                lookup: remeda_1.pipe(candidate_1.getCellsContainingCandidate(digit, candidates, undefined), remeda_1.map(cell_1.getCellCoord), remeda_1.reduce((acc, item) => acc.set(item[lineIndex], [...(acc.get(item[lineIndex]) || []), item[1 - lineIndex]]), new Map())),
            };
        }));
    };
};
const getBasicFishEliminationResult = (candidates, level) => {
    return (subset) => {
        const subsetCells = remeda_1.pipe(subset.line === "row" ? house_1.ROWS_LIST : house_1.COLUMNS_LIST, remeda_1.filter((house) => ramda_1.includes(house.index, subset.result.subsetValues)), remeda_1.map((house) => house.cells), remeda_1.flatten());
        return {
            technique: ramda_1.cond([
                [remeda_1.equals(subset_2.SubsetType.Pair), ramda_1.always("X-Wing")],
                [remeda_1.equals(subset_2.SubsetType.Triple), ramda_1.always("Swordfish")],
                [remeda_1.equals(subset_2.SubsetType.Quadruple), ramda_1.always("Jellyfish")],
            ])(level),
            eliminations: remeda_1.filter([
                {
                    digit: subset.digit,
                    coords: remeda_1.pipe(subset.line === "row" ? house_1.COLUMNS_LIST : house_1.ROWS_LIST, remeda_1.filter((house) => ramda_1.includes(house.index, subset.result.subsetIndexes)), remeda_1.map((house) => remeda_1.difference(house.cells, subsetCells)), remeda_1.flatten(), remeda_1.filter((cell) => ramda_1.includes(subset.digit, candidates.get(cell) || [])), remeda_1.map(cell_1.getCellCoord)),
                },
            ], (elim) => elim.coords.length > 0),
            implication: {
                type: types_2.EliminationImplicationType.Fish,
                line: subset.line,
                digit: subset.digit,
                baseSet: subset.result.subsetValues,
                coverSet: subset.result.subsetIndexes,
            },
        };
    };
};
/**
 * A Basic Fish is formed with a digit that is a candidate for N lines (rows or columns) - the base set - on exactly N
 * opposite lines - the cover set. All candidates of the digit that are on the lines of the cover set but not on the
 * base set can be eliminated.
 *
 * @since 0.0.3
 *
 * @param grid The grid to solve.
 * @param level The level of the subset to find.
 * @returns A list of objects describing where a candidate can be eliminated.
 *
 * @example
 * const grid = parseGrid(
 *   ":0301:2:16.54+3.7..+78+6.1+43+5+43+58.+7+6.+17+2.+45+8.696..9+12.57...+3+7+6..+4.+1+6.3..4.+3...+8..16..+71645.+3::268 271:r239 c158 ",
 *   true,
 * );
 * const results = eliminateBasicFish(grid, SubsetType.Triple);
 * eliminationDescription(results[0]);
 * // => "Swordfish: 2 r239 c158 => r6c8,r7c1<>2"
 *
 * @see http://sudopedia.enjoysudoku.com/Fish.html
 * @see http://sudopedia.enjoysudoku.com/X-Wing.html
 * @see http://sudopedia.enjoysudoku.com/Swordfish.html
 * @see http://sudopedia.enjoysudoku.com/Jellyfish.html
 */
function eliminateBasicFish(grid, level) {
    return remeda_1.pipe(types_1.VALID_DIGITS, remeda_1.map(getLookup(grid.candidates)), remeda_1.flatten(), remeda_1.filter((data) => data.lookup.size > 0), remeda_1.map(subset_1.findSubsets(level)), remeda_1.flatten, remeda_1.map(getBasicFishEliminationResult(grid.candidates, level)), remeda_1.filter((result) => result.eliminations.length > 0));
}
exports.eliminateBasicFish = eliminateBasicFish;
