"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../../types");
const remeda_1 = require("remeda");
const findDigitCells_1 = require("../../../utils/digit/findDigitCells");
const ramda_1 = require("ramda");
const house_1 = require("../../../utils/house");
const solvingResult_1 = require("./solvingResult");
const getLastDigitSolvingResult = ([digit, indexes]) => {
    const row = remeda_1.difference(types_1.VALID_HOUSE_INDEXES, remeda_1.map(indexes, (index) => house_1.getCellRow(index).index))[0];
    const col = remeda_1.difference(types_1.VALID_HOUSE_INDEXES, remeda_1.map(indexes, (index) => house_1.getCellCol(index).index))[0];
    return solvingResult_1.getSolvingResult("Last Digit", [row, col], digit);
};
/**
 * Finds a digit with a single unsolved cell.
 *
 * @since 0.0.2
 *
 * @param {SudokuGrid} grid The grid to solve.
 * @param {number} [skip=0] Indicates to skip some of the solving results.
 * @param {number} [count=1] Indicates the maximum amount of results to return.
 * @returns {readonly SolvingResult[]} A list of objects describing where a digit can be placed.
 *
 * @see http://sudopedia.enjoysudoku.com/Last_Digit.html
 */
function solveLastDigit(grid, skip = 0, count = 1) {
    return remeda_1.pipe(types_1.VALID_DIGITS, remeda_1.map((digit) => [digit, findDigitCells_1.findDigitCells(grid.digits, digit)]), ramda_1.filter((input) => input[1].length === 8), remeda_1.drop(skip), remeda_1.take(count), remeda_1.map(getLastDigitSolvingResult));
}
exports.solveLastDigit = solveLastDigit;
