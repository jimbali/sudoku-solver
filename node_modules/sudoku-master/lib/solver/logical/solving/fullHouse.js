"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../../types");
const remeda_1 = require("remeda");
const house_1 = require("../../../utils/house");
const getHouseValues_1 = require("../../../utils/house/getHouseValues");
const solvingResult_1 = require("./solvingResult");
const ramda_1 = require("ramda");
const getFullHouseSolvingResult = (houseValues) => {
    const cellIndex = remeda_1.pipe(types_1.VALID_CELL_INDEXES, remeda_1.filter((cellIndex) => !ramda_1.includes(cellIndex, [...houseValues.values.keys()])), remeda_1.first());
    const digit = remeda_1.pipe(ramda_1.values(types_1.VALID_DIGITS), remeda_1.difference([...houseValues.values.values()]), remeda_1.first());
    if (cellIndex !== undefined && digit) {
        return solvingResult_1.getSolvingResult("Full House", { houseType: houseValues.house.type, houseIndex: houseValues.house.index, cellIndex }, digit);
    }
    else {
        return undefined;
    }
};
/**
 * Finds a house with a single unsolved cell.
 *
 * @since 0.0.2
 *
 * @param {SudokuGrid} grid The grid to solve.
 * @param {number} [skip=0] Indicates to skip some of the solving results.
 * @param {number} [count=1] Indicates the maximum amount of results to return.
 * @returns {readonly SolvingResult[]} A list of objects describing where a digit can be placed.
 *
 * @see http://sudopedia.enjoysudoku.com/Full_House.html
 */
function solveFullHouse(grid, skip = 0, count = 1) {
    return remeda_1.pipe(house_1.HOUSES_LIST, remeda_1.map(getHouseValues_1.getHouseValues(grid.digits)), remeda_1.filter((result) => result.values.size === 8), remeda_1.map(getFullHouseSolvingResult), remeda_1.filter((result) => !!result), remeda_1.drop(skip), remeda_1.take(count));
}
exports.solveFullHouse = solveFullHouse;
