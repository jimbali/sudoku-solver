"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const candidate_1 = require("../../../utils/candidate");
const remeda_1 = require("remeda");
const house_1 = require("../../../utils/house");
const solvingResult_1 = require("./solvingResult");
const _getHouseSingleCandidates = (candidates) => {
    return (house) => {
        const houseCandidates = house_1.getHouseCandidates(house, candidates);
        return remeda_1.pipe([...houseCandidates.entries()], remeda_1.filter((entry) => { var _a; return entry[1].length === 1 && (((_a = candidates.get(entry[1][0])) === null || _a === void 0 ? void 0 : _a.length) || 0) >= 2; }), remeda_1.map((entry) => {
            return { house, digit: entry[0], index: entry[1][0] };
        }));
    };
};
const getHiddenSingleSolvingResult = (result) => {
    return solvingResult_1.getSolvingResult("Hidden Single", result.index, result.digit);
};
/**
 * Find a house containing a single candidate remaining for a specific digit.
 *
 * @since 0.0.2
 *
 * @param {SudokuGrid} grid The grid to solve.
 * @param {number} [skip=0] Indicates to skip some of the solving results.
 * @param {number} [count=1] Indicates the maximum amount of results to return.
 * @returns {readonly SolvingResult[]} A list of objects describing where a digit can be placed.
 *
 * @see http://sudopedia.enjoysudoku.com/Hidden_Single.html
 */
function solveHiddenSingle(grid, skip = 0, count = 1) {
    const candidates = grid.candidates.size > 0 ? grid.candidates : candidate_1.getCandidates(grid.digits);
    const getHouseSingleCandidates = _getHouseSingleCandidates(candidates);
    return remeda_1.pipe(house_1.HOUSES_LIST, remeda_1.map(getHouseSingleCandidates), remeda_1.flatten(), remeda_1.uniqBy((result) => result.index), remeda_1.drop(skip), remeda_1.take(count), remeda_1.map(getHiddenSingleSolvingResult));
}
exports.solveHiddenSingle = solveHiddenSingle;
