"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../types");
const types_2 = require("../../types");
const fp_1 = require("../../utils/fp");
const house_1 = require("../../utils/house");
const ramda_1 = require("ramda");
const remeda_1 = require("remeda");
const types_3 = require("./types");
const cell_1 = require("../../utils/cell");
/**
 * @private
 */
function getColumnsLengths(candidates) {
    return remeda_1.pipe(types_2.VALID_HOUSE_INDEXES, remeda_1.map((houseIndex) => remeda_1.pipe(types_2.VALID_CELL_INDEXES, remeda_1.map((cellIndex) => cell_1.getCellIndexInGrid({ houseType: "col", houseIndex, cellIndex })), remeda_1.map((gridIndex) => { var _a; return ((_a = candidates.get(gridIndex)) === null || _a === void 0 ? void 0 : _a.length) || 1; }), remeda_1.reduce((acc, item) => Math.max(acc, item), 0))));
}
exports.getColumnsLengths = getColumnsLengths;
function _getCell(pencilmarks, grid) {
    return (index) => [
        index,
        grid.digits.get(index) || (pencilmarks ? grid.candidates.get(index) : undefined),
    ];
}
function _addMissingSpaces(maxCandidatesByCol) {
    return (cell, index) => {
        const columnLength = maxCandidatesByCol[house_1.getCellCol(index).index];
        return cell + " ".repeat(columnLength - cell.length);
    };
}
function _createCell(style, pencilmarks, emptyCellSymbol, maxCandidatesByCol) {
    const addMissingSpaces = pencilmarks && (style === "grid" || style === "sudopedia")
        ? _addMissingSpaces(maxCandidatesByCol)
        : (cell) => cell;
    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore
    return ramda_1.cond([
        [
            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
            // @ts-ignore
            fp_1.applyByIndex(1, ramda_1.is(Number)),
            (cell) => addMissingSpaces(cell[1].toString(), cell[0]),
        ],
        [
            // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
            // @ts-ignore
            fp_1.applyByIndex(1, Array.isArray),
            (cell) => addMissingSpaces(cell[1].join(""), cell[0]),
        ],
        [ramda_1.T, (cell) => addMissingSpaces(emptyCellSymbol, cell[0])],
    ]);
}
function _surroundCell(brackets) {
    return (cell) => (brackets ? `${brackets[0]}${cell}${brackets[1]}` : cell);
}
function _gridSeparator(cellSeparator, maxCandidatesByCol, hasPencilmarks) {
    return ([edgeSymbol, middleSymbol]) => remeda_1.pipe(maxCandidatesByCol, fp_1.groupN(3), remeda_1.map((colsLengths) => hasPencilmarks ? ramda_1.repeat("-", ramda_1.sum(colsLengths) + cellSeparator.length * 4).join("") : "---"), ramda_1.join(middleSymbol), ramda_1.replace(/^(.*)$/, edgeSymbol + "$1" + edgeSymbol));
}
function _gridSymbols(isSudopedia) {
    if (isSudopedia) {
        return ramda_1.cond([
            [remeda_1.equals("start"), ramda_1.always([".", "."])],
            [remeda_1.equals("middle"), ramda_1.always([":", "+"])],
            [remeda_1.equals("end"), ramda_1.always(["'", "'"])],
            [ramda_1.T, ramda_1.always("")],
        ]);
    }
    else {
        // eslint-disable-next-line functional/functional-parameters
        return () => ["+", "+"];
    }
}
/**
 * Converts a Sudoku grid into a string that can be read by humans or converted back into a Sudoku program.
 *
 * @since 0.0.1
 *
 * @param {SudokuGrid} grid The grid to serialize.
 * @param {SerializerOptions} [options] Options to apply on the serialized output.
 * @param {("singleLine" | "multiLines" | "grid" | "sudopedia")} [options.style="singleLine"] Describes the formatting style of the
 * output.
 * @param {boolean} options.pencilmarks Indicates whether to show the candidates on the output.
 * @param {("{}" | "()" | "[]")} [options.brackets=undefined] The brackets to use arround the cells (only for singleLine and
 * multiLines styles).
 * @param {("." | "*" | "-" | "0")} [options.emptyCellSymbol="."] The symbol to use to indicate an empty cell.
 * @returns {string} The grid converted into a string.
 *
 * @example
 * const grid = parseGrid(".234..8..6....7......53.62...5......84.....36......1...52.96......1....7..8..521.");
 * const options = {
 *    style: "singleLine",
 *    pencilmarks: true,
 *    brackets: "{}",
 *  };
 * serializeGrid(grid, options);
 * // => {1579}{2}{3}{4}{16}{19}{8}{579}{159}{6}{189}{149}{289}{128}{7}{3459}{459}{13459}{1479}{1789}{1479}{5}{3}{189}{6}{2}{149}{12379}{13679}{5}{236789}{124678}{123489}{479}{4789}{2489}{8}{4}{179}{279}{1257}{129}{579}{3}{6}{2379}{3679}{679}{236789}{245678}{23489}{1}{45789}{24589}{1347}{5}{2}{378}{9}{6}{34}{48}{348}{349}{369}{469}{1}{248}{2348}{3459}{45689}{7}{3479}{3679}{8}{37}{47}{5}{2}{1}{349}
 */
function serializeGrid(grid, options) {
    const pencilmarks = (options === null || options === void 0 ? void 0 : options.pencilmarks) || false;
    const style = (options === null || options === void 0 ? void 0 : options.style) || types_3.SERIALIZER_STYLES[0];
    const emptyCellSymbol = (!(options === null || options === void 0 ? void 0 : options.pencilmarks) ? options === null || options === void 0 ? void 0 : options.emptyCellSymbol : undefined) || types_1.EMPTY_CELL_SYMBOLS[0];
    const brackets = (options === null || options === void 0 ? void 0 : options.pencilmarks) ? options === null || options === void 0 ? void 0 : options.brackets : undefined;
    const cellSeparator = pencilmarks && (style === "grid" || style === "sudopedia" || !brackets) ? " " : "";
    const maxCandidatesByCol = getColumnsLengths(grid.candidates);
    const gridSeparator = _gridSeparator(cellSeparator, maxCandidatesByCol, pencilmarks);
    const getCell = _getCell(pencilmarks, grid);
    const createCell = _createCell(style, pencilmarks, emptyCellSymbol, maxCandidatesByCol);
    const surroundCell = _surroundCell(brackets);
    const groupByRow = (houseIndex) => remeda_1.pipe(types_2.VALID_CELL_INDEXES, remeda_1.map((cellIndex) => cell_1.getCellIndexInGrid({ houseType: "row", houseIndex, cellIndex })), remeda_1.map(getCell), remeda_1.map(createCell), remeda_1.map(surroundCell), ramda_1.join(cellSeparator));
    const groupByBoxRow = (houseIndex) => remeda_1.pipe(types_2.VALID_CELL_INDEXES, remeda_1.map((cellIndex) => cell_1.getCellIndexInGrid({ houseType: "row", houseIndex, cellIndex })), fp_1.groupN(3), remeda_1.map((gridIndexes) => remeda_1.pipe(gridIndexes, remeda_1.map(getCell), remeda_1.map(createCell), remeda_1.map(surroundCell), ramda_1.prepend("|"), ramda_1.join(cellSeparator))), ramda_1.append("|"), ramda_1.join(cellSeparator));
    const gridSymbols = _gridSymbols(style === "sudopedia");
    switch (style) {
        case "singleLine":
            return remeda_1.pipe(types_2.VALID_GRID_INDEXES, remeda_1.map(getCell), remeda_1.map(createCell), remeda_1.map(surroundCell), ramda_1.join(cellSeparator));
        case "multiLines":
            return remeda_1.pipe(types_2.VALID_HOUSE_INDEXES, remeda_1.map(groupByRow), ramda_1.join("\n"));
        case "grid":
        case "sudopedia":
            return remeda_1.pipe(types_2.VALID_HOUSE_INDEXES, remeda_1.map(groupByBoxRow), ramda_1.insert(6, gridSeparator(gridSymbols("middle"))), ramda_1.insert(3, gridSeparator(gridSymbols("middle"))), ramda_1.prepend(gridSeparator(gridSymbols("start"))), ramda_1.append(gridSeparator(gridSymbols("end"))), ramda_1.join("\n"));
        default:
            return null;
    }
}
exports.serializeGrid = serializeGrid;
