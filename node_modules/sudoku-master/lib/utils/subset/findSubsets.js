"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const remeda_1 = require("remeda");
const tuple_1 = require("../tuple");
const ramda_1 = require("ramda");
const _getIndexesForValue = (lookup) => {
    return (value) => {
        return remeda_1.pipe(lookup, remeda_1.filter((entry) => ramda_1.includes(value, entry[1])), remeda_1.map((entry) => entry[0]));
    };
};
const _getIndexesAssociatedToValues = (lookup) => {
    const getIndexesForValue = _getIndexesForValue([...lookup.entries()]);
    return (values) => {
        return remeda_1.pipe(values, remeda_1.map((value) => {
            return {
                indexes: getIndexesForValue(value),
                values,
                value,
            };
        }));
    };
};
const _findSubsets = (data, level) => {
    const getIndexesAssociatedToValues = _getIndexesAssociatedToValues(data.lookup);
    return remeda_1.pipe(
    // Loop through all the combinations of the values in the lookup
    tuple_1.generateTuples({
        size: level,
        validValues: remeda_1.flatten([...data.lookup.values()]),
        getDuplicates: false,
        getSameValues: false,
    }), 
    // Get all the indexes in the lookup containing the current combination
    remeda_1.map(getIndexesAssociatedToValues), 
    // Ensure that each value is associated to at least two indexes
    remeda_1.filter((results) => results.length > 0 && ramda_1.all((result) => result.indexes.length >= 2, results)), 
    // Keep only one occurence of each index on the subset (e.g. [1, 2, 1, 2, 3, 4] => [1, 2, 3, 4]).
    remeda_1.map((results) => {
        return {
            result: {
                subsetIndexes: remeda_1.pipe(results, remeda_1.map((result) => result.indexes), remeda_1.flatten(), remeda_1.uniq(), remeda_1.sort((a, b) => (typeof a === "number" && typeof b === "number" ? a - b : 0))),
                subsetValues: remeda_1.sort(results[0].values, (a, b) => typeof a === "number" && typeof b === "number" ? a - b : 0),
            },
        };
    }), 
    // Check that the subset is of the appropriate level
    remeda_1.filter((result) => result.result.subsetIndexes.length === level), 
    // Encapsulate the result with the data in parameters
    remeda_1.map(remeda_1.merge(data)));
};
// eslint-disable-next-line functional/functional-parameters,@typescript-eslint/explicit-function-return-type
function findSubsets() {
    // eslint-disable-next-line prefer-rest-params,functional/functional-parameters
    return remeda_1.purry(_findSubsets, arguments);
}
exports.findSubsets = findSubsets;
